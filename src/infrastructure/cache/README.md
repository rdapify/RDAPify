# Cache Implementations

Caching layer for RDAP responses to improve performance and reduce network calls.

## Components

### InMemoryCache
**File:** `InMemoryCache.ts`  
**Purpose:** In-memory LRU cache with TTL support

**Features:**
- LRU (Least Recently Used) eviction policy
- TTL (Time To Live) expiration
- O(1) get/set operations
- Automatic cleanup of expired entries
- Configurable max size

**Usage:**
```typescript
const cache = new InMemoryCache(1000); // Max 1000 entries

// Set with TTL
await cache.set('domain:example.com', response, 3600); // 1 hour

// Get (returns null if expired or not found)
const cached = await cache.get('domain:example.com');

// Check existence
const exists = await cache.has('domain:example.com');

// Get size
const size = await cache.size();

// Clear all
await cache.clear();
```

**LRU Algorithm:**
1. Track access order in array
2. Most recently used items at end of array
3. Least recently used at beginning
4. Evict first item when cache is full
5. Update order on every access

**Memory Management:**
- Automatic eviction when maxSize reached
- Expired entries removed on access
- Manual clear() for full cleanup
- No memory leaks

### CacheManager
**File:** `CacheManager.ts`  
**Purpose:** Strategy pattern wrapper for different cache types

**Strategies:**
- `memory` - In-memory LRU cache (default)
- `redis` - Redis cache (planned for v0.2.0)
- `custom` - User-provided implementation
- `none` - No caching (pass-through)

**Usage:**
```typescript
// Memory cache (default)
const cache = new CacheManager({
  strategy: 'memory',
  ttl: 3600,
  maxSize: 1000
});

// Custom cache
const cache = new CacheManager({
  strategy: 'custom',
  customCache: new MyCustomCache()
});

// No cache
const cache = new CacheManager({
  strategy: 'none'
});
```

**Error Handling:**
- Cache failures don't break application
- Errors logged but not thrown
- Graceful degradation to no-cache
- Application continues without cache

**Statistics:**
```typescript
const stats = await cache.getStats();
// { size: 150, enabled: true, ttl: 3600 }
```

## ICache Interface

All cache implementations must implement:

```typescript
interface ICache {
  get(key: string): Promise<RDAPResponse | null>;
  set(key: string, value: RDAPResponse, ttl?: number): Promise<void>;
  delete(key: string): Promise<void>;
  clear(): Promise<void>;
  has(key: string): Promise<boolean>;
  size(): Promise<number>;
}
```

## Cache Keys

Cache keys follow the pattern: `{type}:{normalized_value}`

**Examples:**
- `domain:example.com`
- `ip:8.8.8.8`
- `asn:15169`

Generated by: `shared/utils/helpers/generateCacheKey()`

## TTL (Time To Live)

**Default:** 3600 seconds (1 hour)

**Rationale:**
- RDAP data changes infrequently
- 1 hour balances freshness vs performance
- Configurable per-query or globally

**Expiration:**
- Checked on every get()
- Expired entries automatically removed
- No background cleanup needed

## Performance

### InMemoryCache
- **Get:** O(1) - Map lookup + array update
- **Set:** O(1) - Map insert + array update
- **Delete:** O(n) - Array search and remove
- **Clear:** O(1) - Map and array clear

### Memory Usage
- Each entry: ~1-5 KB (depends on response size)
- 1000 entries: ~1-5 MB
- Configurable maxSize prevents unbounded growth

### Benchmarks
```
get() (hit):     ~0.01ms
get() (miss):    ~0.01ms
set():           ~0.02ms
eviction:        ~0.05ms
```

## Future: Redis Cache

**Status:** Planned for v0.2.0

**Features:**
- Distributed caching
- Persistence
- Cluster support
- Pub/sub for cache invalidation

**Usage (future):**
```typescript
const cache = new CacheManager({
  strategy: 'redis',
  redis: {
    host: 'localhost',
    port: 6379,
    password: 'secret',
    db: 0
  }
});
```

## Custom Cache Implementation

Implement `ICache` interface:

```typescript
class MyCustomCache implements ICache {
  async get(key: string): Promise<RDAPResponse | null> {
    // Your implementation
  }
  
  async set(key: string, value: RDAPResponse, ttl?: number): Promise<void> {
    // Your implementation
  }
  
  // ... implement other methods
}

// Use it
const cache = new CacheManager({
  strategy: 'custom',
  customCache: new MyCustomCache()
});
```

## Testing

### Unit Tests
```typescript
describe('InMemoryCache', () => {
  it('should store and retrieve values', async () => {
    const cache = new InMemoryCache();
    await cache.set('key', value);
    const result = await cache.get('key');
    expect(result).toEqual(value);
  });
  
  it('should expire entries after TTL', async () => {
    const cache = new InMemoryCache();
    await cache.set('key', value, 1); // 1 second TTL
    await sleep(1100);
    const result = await cache.get('key');
    expect(result).toBeNull();
  });
  
  it('should evict LRU when full', async () => {
    const cache = new InMemoryCache(2); // Max 2 entries
    await cache.set('key1', value1);
    await cache.set('key2', value2);
    await cache.set('key3', value3); // Should evict key1
    expect(await cache.has('key1')).toBe(false);
    expect(await cache.has('key3')).toBe(true);
  });
});
```

## Related

- **Port Interface**: `src/core/ports/cache.port.ts`
- **Cache Manager**: Used by `application/client/RDAPClient.ts`
- **Key Generation**: `src/shared/utils/helpers/generateCacheKey.ts`

---

**Implements**: `ICachePort` from Core layer  
**Used by**: Application layer (RDAPClient)  
**Status**: Fully implemented and tested
